#!/usr/bin/perl
#
# fh_test_driver
# (c) 2014 SUSE Linux Products GmbH
# Author: Fabian Herschel
# License: GPL v2+
# Version: 0.8.2015.03.19.1-scale-out
#
##################################################################
# THIS PROGRAM IS NOT INTENDED TO RUN IN PRODUCTIVE ENVIRONMENTS
# AS IT TESTS THE FUNCTIONALITY OF THE SAPHanaSR RESOURCE AGENTS
# THEIRFORE IT STOPS, KILLS AND EVEN MORE SAP HANA INSTANCES AND
# ALSO SHUTDOWN, FENCES OR BLOCK CLUSTER NODES
##################################################################

use POSIX;
use strict;
use Sys::Syslog;
use Sys::Hostname;
use File::Path;

###################################
## this part is not for scale out and currently NOT zero-config

my $ClusterNodes=6;
my $ClusterPrimaries=$ClusterNodes / 2;
my $ClusterSecondaries=$ClusterNodes / 2;

my %Name;
my %Host;
my $host = hostname();

my $varlib='/var/lib/SAPHanaTD';
my $testfile='SAPHanaTD.status';
my $testcount=0;
my $testCase=0;
my $msl;
my $first_test=1;

    my $message;
    my $phost;
    my $shost;
    my $sSite="";
    my $pSite="";

sub init() 
{
    mkpath($varlib, { mode => 0700, });
    open(STATFILE, "<", "$varlib/$testfile");
    while (<STATFILE>) {
      if ( /^testnr=(.+)/ ) {
         $testcount=$1;
      }
    }
    $msl="msl_";
    #$msl="msl_SAPHana_SLE_HDB00";
#crm resource list
# stonith_fscs98 (stonith:external/ipmi):        Started 
# stonith_fscs99 (stonith:external/ipmi):        Started 
# rsc_ip_SLE_HDB00       (ocf::heartbeat:IPaddr2):       Started 
# Master/Slave Set: msl_SAPHana_SLE_HDB00 [rsc_SAPHana_SLE_HDB00]
    open crmRList, "crm resource list |";
    while (<crmRList>) {
        #printf "%s", $_;
        if (/^\s*Master.Slave Set:\s+(\S+)\s+/) {
           printf "master-slave resource found: <%s> \n", $1;
           $msl=$1;
        }
    }
    close crmRList;
    close STATFILE;
    return 0;
}


sub max { # thanks to http://www.perlunity.de/perl/forum/thread_018329.shtml
 my $a = shift;
 my $b = shift;
 return $a > $b ? $a : $b;
}

sub mysyslog ( $$$ ) {
   my ($prio, $form, @param) = ( @_ );
   printf "$form", @param;
   syslog $prio, $form, @param;


}

sub get_nodes_online() 
{
    my $rc=0;
    my $match="Ok:\s+([0-9])\s+nodes online";
    my $match="Ok:\s+([0-9]+)\s+nodes? online";
    my $match="Ok: ([0-9]+) ";
    open crm, "crm_mon -s |";
    while (<crm>) {
        if (/$match/) {
           $rc=$1
        }
    }
    close crm;
    return $rc;
}

sub get_node_status($)
{
    # typically returns online, standby or offline
    my $result="offline";
    my $node=shift;
    open crm, "crm_mon -1 |";
    #- case one offline/standby and one online
    # Node fscs99: OFFLINE (standby)
    # Online: [ fscs98 ]
    #- case both standby
    # Node fscs99: standby
    # Node fscs98: standby
    #- case one standby one online
    # Node fscs99: standby
    # Online: [ fscs98 ]
    #- case both online
    # Online: [ fscs98 fscs99 ]
    while (<crm>) {
        if ( /^Online:.*\s$node\s/ ) {
           #printf("O: %s\n", $_);
           $result="online";
        } elsif ( /^Node\s+$node:\s+(\S+)/  ) {
           #printf("N: %s: %s\n", $_, $1);
           $result=tolower($1);

        }
    }
    close crm;
    return $result;
}

#
# works only, if ONE SAPinstance (here HANA) is installed on the cluster
#
sub get_sid_and_InstNr()
{
    my $sid=""; my $Inr="";
    open ListInstances, "/usr/sap/hostctrl/exe/saphostctrl -function ListInstances|";
    while (<ListInstances>) {
       # try to catch:  Inst Info : LNX - 42 - lv9041 - 740, patch 36, changelist 1444691
       chomp;
       if ( $_ =~ /:\s+([A-Z][A-Z0-9][A-Z0-9])\s+-\s+([0-9][0-9])/ ) {
          $sid=tolower("$1");
          $Inr=$2;
       }
    }
    close ListInstances;
    return ( $sid, $Inr );
}

sub get_hana_attributes($)
{
    my $sid = shift;
    my $table_title = "Host \\ Attr";
    open CIB, "cibadmin -Ql |";
    while (<CIB>) {
       my ($host, $name, $value);
       my $found_attr=0;
       chomp;
# <nvpair name="hana_lnx_vhost" value="lv9041" id="nodes-lv9041-hana_lnx_vhost"/>

       if ( $_ =~ /nvpair\s+id="status-([a-zA-Z0-9]+)-\w+"\s+name="(\w+_${sid}_\w+)"\s+value="([^"]+)"/ ) {
           $found_attr=1;
           ($host, $name, $value) = ( $1, $2, $3 );
       }

       if ( $_ =~ /nvpair\s+name="(\w+_${sid}_\w+)"\s+value="([^"]+)"\s+id="nodes-([a-zA-Z0-9]+)-\w+"/ ) {
           $found_attr=1;
           ($name, $value, $host) = ( $1, $2, $3 );
       }
       if ( $found_attr ) {
           #
           # handle the hosts name and table-title
           #
           $Host{$host}->{$name}=${value};
           if ( defined ($Name{_hosts}->{_length})) {
              $Name{_hosts}->{_length} = max($Name{_hosts}->{_length}, length($host ));
           } else {
              $Name{_hosts}->{_length} = length($host );
           }
           $Name{_hosts}->{_length} = max($Name{_hosts}->{_length}, length( $table_title));
           #
           # now handle the attributes name and value
           #
           $Name{$name}->{$host}=${value};
#printf "get_hana_attributes(): \$Name{%s}->{%s}=\${%s}\n", $name, $host, $value;
           if ( defined ($Name{$name}->{_length})) {
              $Name{$name}->{_length} = max($Name{$name}->{_length}, length($value ));
           } else {
              $Name{$name}->{_length} = length($value );
           }
           if ( $name =~ /hana_${sid}_(.*)/ ) {
              $Name{$name}->{_title} =  $1;
           } else {
              $Name{$name}->{_title} = $name; 
           }
           $Name{$name}->{_length} = max($Name{$name}->{_length}, length( $Name{$name}->{_title}));
       }
    }
    close CIB;
    return 0;
}

sub get_hana_sync_state($)
{
    my $sid=shift;
    my $result="";
    my $h;
    foreach $h ( keys(%{$Name{"hana_${sid}_sync_state"}}) ) {
        if ( $Name{"hana_${sid}_sync_state"}->{$h} =~ /(S.*)/ ) {
           $result=$1;
        }
    }
    return $result;
}

sub get_number_primary($ $)
{
    my $sid=shift;
    my $lss=shift;
    my $rc=0;
    my $h;
    foreach $h ( keys(%{$Name{"hana_${sid}_roles"}}) ) {
        if ( $Name{"hana_${sid}_roles"}->{$h} =~ /[$lss]:P:/ ) {
           $rc++;
        }
    }
    return $rc;
}

sub get_number_secondary($ $)
{
    my $sid=shift;
    my $lss=shift;
    my $rc=0;
    my $h;
    foreach $h ( keys(%{$Name{"hana_${sid}_roles"}}) ) {
        if ( $Name{"hana_${sid}_roles"}->{$h} =~ /[$lss]:S:/ ) {
           $rc++;
        }
    }
    return $rc;
}

sub get_host_primary($ $)
{
    my $sid=shift;
    my $lss=shift;
    my $result="";
    my $h;
    foreach $h ( keys(%{$Name{"hana_${sid}_roles"}}) ) {
        if ( $Name{"hana_${sid}_roles"}->{$h} =~ /[$lss]:P:master.:master/ ) {
           $result=$h;
        }
    }
    return $result;
}

sub get_host_secondary($ $)
{
    my $sid=shift;
    my $lss=shift;
    my $result="";
    my $h;
    foreach $h ( keys(%{$Name{"hana_${sid}_roles"}}) ) {
        if ( $Name{"hana_${sid}_roles"}->{$h} =~ /[$lss]:S:master.:master/ ) {
           $result=$h;
        }
    }
    return $result;
}

sub get_site_by_host($ $)
{
    my $result="";
    my $sid=shift;
    my $h = shift;
    $result = $Name{"hana_${sid}_site"}->{$h};
    return $result;                                                                                                                                                                                                
}

sub check_all_ok($)
{
    my $sid=shift;
    my $rc=0;
    my $failed="";
    my $result;
    $result=get_nodes_online;
    if ( $result != $ClusterNodes ) {
         $rc++;  
         $failed .= " #N=$result"; 
    }
    $result=get_hana_sync_state($sid);
    if ( $result ne "SOK" ) {
         $rc++;  
         $failed .= " sync=$result ";
    }
    $result=get_number_primary($sid, "34");
    if ( $result != $ClusterPrimaries ) {
         $rc++;  
         $failed .= " #P=$result ";
    }
    $result=get_number_secondary($sid, "34");
    if ( $result != $ClusterSecondaries ) {
         $rc++;  
         $failed .= " #S=$result ";
    }
    return ($rc, $failed);
}

my $ident = "fhTD";
my $logopt = "pid";
my $facility = "LOCAL0";
my $priority = "info";

openlog $ident, $logopt, $facility;       # don't forget this
my $sid="";
my $INr="";
    
( $sid, $INr ) = get_sid_and_InstNr();

#if (get_nodes_online(2)) {
#    printf "Both online\n";
#}
#if (get_nodes_online(1)) {
#    printf "One  online\n";
#}
#
#printf "status=%s\n",get_node_status("fscs99");
#
#printf "sync=%s\n", get_hana_sync_state($sid);
#printf "ok_prims=%s\n", get_number_primary($sid, "34");
#printf "ok_secs=%s\n", get_number_secondary($sid, "34");
#printf "warn_prims=%s\n", get_number_primary($sid, "2");


# TODO: For all tests we need to define the pre-requisite, the test action and the expected-test-result
#       Like: STOP_HANA_PRIMARY  :  ALL_OK :   TAKEOVER + ALL_OK (after some time ;-)
#             STOP_HANA_SECONDARY : ALL_OK :   NOTAKEOVER + ALL_OK (after some time ;-)
#             STANDBY_NODE_PRIMARY : ALL_OK :  TAKEOVER + ALL_OK, lost secondary, one node standby
#             ONLINE_NODE : ALL_OK, lost secondary, node standby : NOTAKEOVER + ALL_OK
#             STANDBY_NODE_SECONDARY: ALL_OK : NOTAKEOVER + ALL_OK, lost secondary, node standby
#             KILL_DEAMON_PRIMARY : ALL_OK ....
#             KILL_DAEMON_SECONDARY : ALL_OK ...
#             KILL_DAEMON_BOTH :
#             STANDBY_NODE_BOTH :
#             ONLINE_NODE_BOTH :
#             FENCE_NODE_PRIMARY :
#             FENCE_NODE_SECONDARY :
#             STOP_CLUSTER_PRIMARY :
#             START_CLUSTER :
#             STOP_CLUSTER_SECONDARY :
#             BREAK_SYNC :
#             REPAIR_SYNC :
#             UNMANAGE_RESOURCE :
#             MANAGE_RESOURCE : 
#     Either we use tests like the above - defined one per line - or we use complete test modules which tests a 
#     failere, messures the reaction (immediate not-ALL_OK) than doing a "anti-dot-action" and checking if ALL_OK
#     comes back and than to run the next test module.
#     A test module would be:
#             STOP_HANA_PRIMARY + WAIT + CHECK
#             STANDBY_NODE_PRIMARY + WAIT + ONLINE_NODE + WAIT + CHECK
#             FENCE_NODE_PRIMARY + WAIT + START_CLUSTER + WAIT + CHECK
#     For all FENCE, CLUSTER, BOOT ACTIONS we need to run either without cluster interaction (as fallback) and we need to
#     run exactly on one node per time only (maybe we use DC)
#             

sub run_test_stop_hana( $ $ $ ) 
{
    my $sid=shift;
    my $theHost=shift;
    my $testNr=shift;
    my $rc=0;
       my $SID=toupper($sid);
    mysyslog $priority, "%s", "TEST Try to stop HDB at $theHost test=$testNr";
    if ( $theHost eq $host ) {
       # local
	    mysyslog $priority, "%s", "TEST su - ${sid}adm -c \"HDB stop\" test=$testNr";
       system("su - ${sid}adm -c \"HDB stop\"");
    } else {
            mysyslog $priority, "%s", "TEST ssh ${sid}adm\@$theHost HDB stop test=$testNr";
       # remote
       system("ssh ${sid}adm\@$theHost \"/usr/sap/$SID/HDB$INr/HDB stop\"");
    }
    mysyslog $priority, "%s", "TEST Stopped HDB at $theHost test=$testNr";
    return $rc;
}

sub run_test_kill_hana( $ $ $ $ ) 
{
    my $sid=shift;
    my $theHost=shift;
    my $testNr=shift;
    my $signal=shift;
    my $rc=0;
       my $SID=toupper($sid);
    mysyslog $priority, "%s", "TEST Try to kill-$signal HDB at $theHost test=$testNr";
    if ( $theHost eq $host ) {
       # local
	    mysyslog $priority, "%s", "TEST su - ${sid}adm -c \"HDB kill-$signal\" test=$testNr";
       system("su - ${sid}adm -c \"HDB kill-$signal\"");
    } else {
       # remote
            mysyslog $priority, "%s", "TEST ssh ${sid}adm\@$theHost bash -lc \"HDB kill-$signal\" test=$testNr";
       system("ssh ${sid}adm\@$theHost \"/usr/sap/$SID/HDB$INr/HDB kill-$signal\"");
    }
    mysyslog $priority, "%s", "TEST Killed HDB at $theHost test=$testNr";
    return $rc;
}

sub run_test_standby_node( $ $ $ )
{
    my $sid=shift;
    my $node=shift;
    my $testNr=shift;
    my $rc=0;
    if ( get_nodes_online() == 2 ) {
        mysyslog $priority, "%s", "Try standby $node test=$testNr";
        system("crm node standby $node");
        while ( get_nodes_online() != 1 ) {
            mysyslog $priority, "%s", "Wait for standby status for $node test=$testNr";
            sleep 10;
        }
        mysyslog $priority, "%s", "Set standby for $node test=$testNr";
        # TODO: We should wait till S_IDLE - for now we wait for 3 minutes
        mysyslog $priority, "%s", "sleeping 180s test=$testNr";
        sleep 180;
        mysyslog $priority, "%s", "Try set online for $node test=$testNr";
        system("crm node online $node");
        while ( get_nodes_online() != 2 ) {
            mysyslog $priority, "%s", "Wait for online status for $node test=$testNr";
            sleep 10;
        }
        mysyslog $priority, "%s", "Set online for $node test=$testNr";
    }
    return $rc;
}

sub run_test_stop_masterslave( $ $ )
{
    my $msl=shift;
    my $testNr=shift;
    mysyslog $priority, "%s", "Try stop msl $msl test=$testNr";
    system("crm resource stop $msl");
    mysyslog $priority, "%s", "sleeping 180s test=$testNr";
    sleep 180;
    mysyslog $priority, "%s", "Try start msl $msl test=$testNr";
    system("crm resource start $msl");
    return 0;
}

sub run_testCase($)
{
    use Switch;
    my $testCase=shift;
    switch ($testCase) {
        case [1] { 
            mysyslog $priority, "%s", "Testcase $testCase: Kill-2 primary SAP Hana instance. test=$testcount";
            run_test_kill_hana($sid, $phost, $testcount, 2); 
        }
        case [2] { 
            mysyslog $priority, "%s", "Testcase $testCase: Kill-2 secondary SAP Hana instance. test=$testcount";
            run_test_kill_hana($sid, $shost, $testcount, 2); 
        }
        case [3] { 
            mysyslog $priority, "%s", "Testcase $testCase: Kill-11 primary SAP Hana instance. test=$testcount";
            run_test_kill_hana($sid, $phost, $testcount, 11); 
        }
        case [4] { 
            mysyslog $priority, "%s", "Testcase $testCase: Kill-11 secondary SAP Hana instance. test=$testcount";
            run_test_kill_hana($sid, $shost, $testcount, 11); 
        } 
        case [5] { 
            mysyslog $priority, "%s", "Testcase $testCase: Stop secondary SAP Hana instance. test=$testcount";
            run_test_stop_hana($sid, $shost, $testcount); 
        }
        case [6] { 
            mysyslog $priority, "%s", "Testcase $testCase: Stop primary SAP Hana instance. test=$testcount";
            run_test_stop_hana($sid, $phost, $testcount); 
        } # maybe add max wished test time till good again?  
        case [7] { 
            mysyslog $priority, "%s", "Testcase $testCase: Kill-9 primary SAP Hana instance. test=$testcount";
            run_test_kill_hana($sid, $phost, $testcount, 9); 
        }
        case [8] { 
            mysyslog $priority, "%s", "Testcase $testCase: Kill-9 secondary SAP Hana instance. test=$testcount";
            run_test_kill_hana($sid, $shost, $testcount, 9); 
        } 
        case [9] {
            mysyslog $priority, "%s", "Testcase $testCase: standby node with secondary SAP Hana instance. test=$testcount";
            run_test_standby_node($sid, $shost, $testcount); 
        }
        case [10] {
            mysyslog $priority, "%s", "Testcase $testCase: standby node with primary SAP Hana instance. test=$testcount";
            run_test_standby_node($sid, $phost, $testcount); 
        }
        case [11] {
            mysyslog $priority, "%s", "Testcase $testCase: stop and start master/slave";
            run_test_stop_masterslave($msl, $testcount);
        }
        else   { 
            mysyslog $priority, "%s", "Uncovered test case number";}
        }
}

init();
mysyslog $priority, "fhTD: Tests running. Next TestNr=%i\n", $testcount;
my $goodloops=0;
my $badloops=0;
my $testActive=0;
while ( 1==1 ) {
    get_hana_attributes($sid);
    $phost=get_host_primary($sid, "1234");
    $shost=get_host_secondary($sid, "1234");
    $pSite=get_site_by_host($sid, $phost);
    $sSite=get_site_by_host($sid, $shost);
    my ($checkOK, $failures ) = check_all_ok($sid);
    if ( ( $checkOK == 0 ) && ( $testActive==0 ) ) {
        #
        # OK back again after it failed
        #
        $badloops=0;
        $goodloops++;
        $message="All checks passed - primary=$phost ($pSite) secondary=$shost ($sSite) loop=$goodloops testnr=$testcount\n";
        mysyslog $priority, "%s", $message;
        if ( ( $goodloops >= 12 ) || ( $first_test == 1 )  ) {
            $testcount++;
            $first_test=0;
            # TODO: Later add other values for writing the status file (now only testnr)
            $message="STATUS primary=$phost ($pSite) secondary=$shost ($sSite) testnr=$testcount\n";
            mysyslog $priority, "%s", $message;
            open(STATFILE, ">", "$varlib/$testfile");
            printf STATFILE "testnr=%i\n", $testcount;
            close STATFILE;
            my $maxTestCase=10;
            # $testCase=$testcount % $maxTestCase + 1 ;
            $testCase=1;
            run_testCase($testCase);
            $testActive=1;
            $goodloops=0;
        }
    } elsif ( ( $checkOK == 0 ) && ( $testActive==1 ) ) {
        #
        # STILL OK after a test, so cluster did not already catched the problem
        #
        $goodloops++;
        $message="Still all checks passed - primary=$phost ($pSite) secondary=$shost ($sSite) loop=$goodloops testnr=$testcount\n";
        mysyslog $priority, "%s", $message;
    } else {
        $goodloops=0;
        $badloops++;
        $testActive=0;
        if ( $checkOK == 1 ) {
		$message="$checkOK check failed ($failures) - primary=$phost ($pSite) secondary=$shost ($sSite) loop=$badloops test=$testcount\n";
        } else {
		$message="$checkOK checks failed ($failures) - primary=$phost ($pSite) secondary=$shost ($sSite) loop=$badloops test=$testcount\n";
        }
        mysyslog $priority, "%s", $message;
    }
    #printf "%s\n", $message;
    sleep 10;
}
  
#$oldmask = setlogmask $mask_priority;
closelog;
